Introduce $osname variable, and compute $arch, $osrelease and $osname the same
way that robotpkg does.

--- fsops.c~	2026-02-10 09:28:26.000000000 +0100
+++ fsops.c	2026-02-10 14:32:50.903700835 +0100
@@ -42,6 +42,7 @@
 } var[] = {
 	{ "$arch", getosarch },
 	{ "$osrelease", getosrelease },
+	{ "$osname", getosname },
 	{ NULL, NULL }
 };
 
--- tools.h~	2026-02-10 09:28:26.000000000 +0100
+++ tools.h	2026-02-10 14:20:13.296179176 +0100
@@ -117,6 +117,7 @@
 extern char *strreplace(char *, const char *, const char *);
 extern char *getosarch(void);
 extern char *getosrelease(void);
+extern char *getosname(void);
 extern int check_yesno(uint8_t);
 
 #endif
--- tools.c~	2026-02-10 17:19:38.510498957 +0100
+++ tools.c	2026-02-10 17:19:43.837553181 +0100
@@ -28,6 +28,7 @@
  */
 
 #include "tools.h"
+#include "opsys.h"
 
 int
 charcount(char *str, char c)
@@ -126,19 +125,37 @@
 char *
 getosrelease(void)
 {
-	struct utsname	un;
-	char			*ret, *p;
+  char *ret, buf[1024];
 
-	memset(&un, 0, sizeof(un));
-	if (uname(&un) < 0)
-		return NULL;
+  FILE *u = popen(robotpkg_opsys, "r");
+  if (!u) return NULL;
 
-	ret = xstrdup(un.release);
+  if (!fgets(buf, sizeof(buf), u)) return NULL;
+  pclose(u);
 
-	for (p = ret; isdigit((int)*p) || *p == '.'; p++);
-	*p = '\0';
+  ret = strtok(buf, " \t\n");
+  ret = strtok(NULL, " \t\n");
+  if (!ret) return NULL;
 
-	return ret;
+  return strdup(ret);
+}
+
+/* Return os name or NULL in case of failure */
+char *
+getosname(void)
+{
+  char *ret, buf[1024];
+
+  FILE *u = popen(robotpkg_opsys, "r");
+  if (!u) return NULL;
+
+  if (!fgets(buf, sizeof(buf), u)) return NULL;
+  pclose(u);
+
+  ret = strtok(buf, " \t\n");
+  if (!ret) return NULL;
+
+  return strdup(ret);
 }
 
 /*
